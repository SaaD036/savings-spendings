{"version":3,"file":"firesql.es5.js","sources":["../src/utils.ts","../src/select/groupby.ts","../src/select/orderby.ts","../src/select/limit.ts","../src/select/where.ts","../src/select/index.ts","../src/firesql.ts","../src/rx/index.ts"],"sourcesContent":["import { SQL_Value, SQL_AggrFunction } from 'node-sqlparser';\r\n\r\nexport type DocumentData = { [field: string]: any };\r\n\r\nexport type ValueOf<T> = T[keyof T];\r\n\r\nexport function assert(condition: boolean, message: string) {\r\n  if (!condition) {\r\n    throw new Error(message);\r\n  }\r\n}\r\n\r\nexport function contains(obj: object, prop: string): boolean {\r\n  return Object.prototype.hasOwnProperty.call(obj, prop);\r\n}\r\n\r\nexport function safeGet(obj: any, prop: string): any {\r\n  if (contains(obj, prop)) return obj[prop];\r\n}\r\n\r\nexport function deepGet(obj: any, path: string): any {\r\n  let value = obj;\r\n  const props = path.split('.');\r\n\r\n  props.some(prop => {\r\n    value = safeGet(value, prop);\r\n\r\n    // By using \"some\" instead of \"forEach\", we can return\r\n    // true whenever we want to break out of the loop.\r\n    return typeof value === void 0;\r\n  });\r\n\r\n  return value;\r\n}\r\n\r\nexport function astValueToNative(\r\n  astValue: SQL_Value\r\n): boolean | string | number | null {\r\n  let value: boolean | string | number | null;\r\n\r\n  switch (astValue.type) {\r\n    case 'bool':\r\n    case 'null':\r\n    case 'string':\r\n      value = astValue.value;\r\n      break;\r\n    case 'number':\r\n      value = Number(astValue.value);\r\n      break;\r\n    default:\r\n      throw new Error('Unsupported value type in WHERE clause.');\r\n  }\r\n\r\n  return value;\r\n}\r\n/**\r\n * Adapted from: https://github.com/firebase/firebase-ios-sdk/blob/14dd9dc2704038c3bf702426439683cee4dc941a/Firestore/core/src/firebase/firestore/util/string_util.cc#L23-L40\r\n */\r\nexport function prefixSuccessor(prefix: string): string {\r\n  // We can increment the last character in the string and be done\r\n  // unless that character is 255 (0xff), in which case we have to erase the\r\n  // last character and increment the previous character, unless that\r\n  // is 255, etc. If the string is empty or consists entirely of\r\n  // 255's, we just return the empty string.\r\n  let limit = prefix;\r\n  while (limit.length > 0) {\r\n    const index = limit.length - 1;\r\n    if (limit[index] === '\\xff') {\r\n      limit = limit.slice(0, -1);\r\n    } else {\r\n      limit =\r\n        limit.substr(0, index) +\r\n        String.fromCharCode(limit.charCodeAt(index) + 1);\r\n      break;\r\n    }\r\n  }\r\n  return limit;\r\n}\r\n\r\nexport function nameOrAlias(\r\n  name: string,\r\n  alias: string | null,\r\n  aggrFn?: SQL_AggrFunction\r\n): string {\r\n  if (alias !== null && alias.length > 0) {\r\n    return alias;\r\n  }\r\n\r\n  if (!aggrFn) {\r\n    return name;\r\n  }\r\n\r\n  return `${aggrFn.name}(${name})`;\r\n}\r\n","import { SQL_GroupBy } from 'node-sqlparser';\r\nimport { assert, safeGet, contains, DocumentData, ValueOf } from '../utils';\r\n\r\nexport function applyGroupByLocally(\r\n  documents: DocumentData[],\r\n  astGroupBy: SQL_GroupBy[]\r\n): GroupedDocuments {\r\n  assert(astGroupBy.length > 0, 'GROUP BY needs at least 1 group.');\r\n\r\n  let group: ValueOf<GroupedDocuments> = new DocumentsGroup();\r\n  group.documents = documents;\r\n\r\n  astGroupBy.forEach(groupBy => {\r\n    assert(\r\n      groupBy.type === 'column_ref',\r\n      'GROUP BY only supports grouping by field names.'\r\n    );\r\n    group = applySingleGroupBy(group, groupBy);\r\n  });\r\n\r\n  return (group as any) as GroupedDocuments;\r\n}\r\n\r\nfunction applySingleGroupBy(\r\n  documents: ValueOf<GroupedDocuments>,\r\n  groupBy: SQL_GroupBy\r\n): GroupedDocuments {\r\n  const groupedDocs: GroupedDocuments = {};\r\n\r\n  if (documents instanceof DocumentsGroup) {\r\n    // We just have a list of documents\r\n    const numDocs = documents.documents.length;\r\n\r\n    for (let i = 0; i < numDocs; i++) {\r\n      const doc = documents.documents[i];\r\n\r\n      // Since we're going to use the value as an object key, always\r\n      // coherce it to a string in case it's some other type.\r\n      const groupValue = String(safeGet(doc, groupBy.column));\r\n\r\n      if (!contains(groupedDocs, groupValue)) {\r\n        groupedDocs[groupValue] = new DocumentsGroup();\r\n      }\r\n\r\n      (groupedDocs[groupValue] as DocumentsGroup).documents.push(doc);\r\n    }\r\n\r\n    return groupedDocs;\r\n  } else {\r\n    // We have documents that have already been grouped with another field\r\n    const currentGroups = Object.keys(documents);\r\n    currentGroups.forEach(group => {\r\n      groupedDocs[group] = applySingleGroupBy(documents[group], groupBy);\r\n    });\r\n    return groupedDocs;\r\n  }\r\n}\r\n\r\nexport class DocumentsGroup {\r\n  documents: DocumentData[] = [];\r\n  aggr: GroupAggregateValues = {\r\n    sum: {},\r\n    avg: {},\r\n    min: {},\r\n    max: {},\r\n    total: {}\r\n  };\r\n\r\n  constructor(public key?: string) {}\r\n}\r\n\r\nexport interface GroupedDocuments {\r\n  [key: string]: GroupedDocuments | DocumentsGroup;\r\n}\r\n\r\nexport interface GroupAggregateValues {\r\n  sum: { [k: string]: number };\r\n  avg: { [k: string]: number };\r\n  min: { [k: string]: number | string };\r\n  max: { [k: string]: number | string };\r\n  total: { [k: string]: number };\r\n}\r\n","import { assert, prefixSuccessor } from '../utils';\r\n\r\nexport function applyOrderBy(\r\n  queries: firebase.firestore.Query[],\r\n  astOrderBy: any[]\r\n): firebase.firestore.Query[] {\r\n  astOrderBy.forEach(orderBy => {\r\n    assert(\r\n      orderBy.expr.type === 'column_ref',\r\n      'ORDER BY only supports ordering by field names.'\r\n    );\r\n\r\n    queries = queries.map(query =>\r\n      query.orderBy(orderBy.expr.column, orderBy.type.toLowerCase())\r\n    );\r\n  });\r\n\r\n  return queries;\r\n}\r\n\r\nexport function applyOrderByLocally(\r\n  docs: firebase.firestore.DocumentData[],\r\n  astOrderBy: any[]\r\n): firebase.firestore.DocumentData[] {\r\n  return docs.sort((doc1, doc2) => {\r\n    return astOrderBy.reduce<number>((result, orderBy) => {\r\n      if (result !== 0) {\r\n        // We already found a way to sort these 2 documents, so there's\r\n        // no need to keep going. This doesn't actually break out of the\r\n        // reducer but prevents doing any further unnecessary and\r\n        // potentially expensive comparisons.\r\n        return result;\r\n      }\r\n\r\n      const field = orderBy.expr.column;\r\n\r\n      if (doc1[field] < doc2[field]) {\r\n        result = -1;\r\n      } else if (doc1[field] > doc2[field]) {\r\n        result = 1;\r\n      } else {\r\n        result = 0;\r\n      }\r\n\r\n      if (orderBy.type === 'DESC' && result !== 0) {\r\n        result = -result;\r\n      }\r\n\r\n      return result;\r\n    }, 0);\r\n  });\r\n}\r\n","import { assert, prefixSuccessor, astValueToNative } from '../utils';\r\n\r\nexport function applyLimit(\r\n  queries: firebase.firestore.Query[],\r\n  astLimit: any[]\r\n): firebase.firestore.Query[] {\r\n  // node-sqlparser's implementation of LIMIT is a bit buggy.\r\n  // If limit and offset are passed, it returns an array where\r\n  // the first item is the limit and the second one is the\r\n  // offset, but if no offset is specified then the first item\r\n  // in the array is the number 0 and the second one contains\r\n  // the actual limit.\r\n  // Plus, it throws an error if there's a newline character\r\n  // following the limit.\r\n  assert(\r\n    astLimit[0].value === 0,\r\n    \"LIMIT doesn't support specifying an OFFSET.\"\r\n  );\r\n  const limit = astValueToNative(astLimit[1]) as number;\r\n  return queries.map(query => query.limit(limit));\r\n}\r\n\r\nexport function applyLimitLocally(\r\n  docs: firebase.firestore.DocumentData[],\r\n  astLimit: any[]\r\n): firebase.firestore.DocumentData[] {\r\n  const limit = astValueToNative(astLimit[1]) as number;\r\n  docs.splice(limit);\r\n  return docs;\r\n}\r\n","import { SQL_Value, SQL_ValueString, SQL_ValueBool } from 'node-sqlparser';\r\nimport { assert, prefixSuccessor, astValueToNative } from '../utils';\r\n\r\nexport function applyWhere(\r\n  queries: firebase.firestore.Query[],\r\n  astWhere: { [k: string]: any }\r\n): firebase.firestore.Query[] {\r\n  if (astWhere.type === 'binary_expr') {\r\n    if (astWhere.operator === 'AND') {\r\n      queries = applyWhere(queries, astWhere.left);\r\n      queries = applyWhere(queries, astWhere.right);\r\n    } else if (astWhere.operator === 'OR') {\r\n      queries = [\r\n        ...applyWhere(queries, astWhere.left),\r\n        ...applyWhere(queries, astWhere.right)\r\n      ];\r\n    } else if (astWhere.operator === 'IN') {\r\n      assert(\r\n        astWhere.left.type === 'column_ref',\r\n        'Unsupported WHERE type on left side.'\r\n      );\r\n      assert(\r\n        astWhere.right.type === 'expr_list',\r\n        'Unsupported WHERE type on right side.'\r\n      );\r\n\r\n      const newQueries: firebase.firestore.Query[] = [];\r\n      astWhere.right.value.forEach((valueObj: SQL_Value) => {\r\n        newQueries.push(\r\n          ...applyCondition(queries, astWhere.left.column, '=', valueObj)\r\n        );\r\n      });\r\n      queries = newQueries;\r\n    } else if (astWhere.operator === 'LIKE') {\r\n      assert(\r\n        astWhere.left.type === 'column_ref',\r\n        'Unsupported WHERE type on left side.'\r\n      );\r\n      assert(\r\n        astWhere.right.type === 'string',\r\n        'Only strings are supported with LIKE in WHERE clause.'\r\n      );\r\n\r\n      const whereLike = parseWhereLike(astWhere.right.value);\r\n\r\n      if (whereLike.equals !== void 0) {\r\n        queries = applyCondition(\r\n          queries,\r\n          astWhere.left.column,\r\n          '=',\r\n          whereLike.equals\r\n        );\r\n      } else if (whereLike.beginsWith !== void 0) {\r\n        const successorStr = prefixSuccessor(whereLike.beginsWith.value);\r\n        queries = applyCondition(\r\n          queries,\r\n          astWhere.left.column,\r\n          '>=',\r\n          whereLike.beginsWith\r\n        );\r\n        queries = applyCondition(\r\n          queries,\r\n          astWhere.left.column,\r\n          '<',\r\n          stringASTWhereValue(successorStr)\r\n        );\r\n      } else {\r\n        throw new Error(\r\n          'Only terms in the form of \"value%\" (string begins with value) and \"value\" (string equals value) are supported with LIKE in WHERE clause.'\r\n        );\r\n      }\r\n    } else if (astWhere.operator === 'BETWEEN') {\r\n      assert(\r\n        astWhere.left.type === 'column_ref',\r\n        'Unsupported WHERE type on left side.'\r\n      );\r\n      assert(\r\n        astWhere.right.type === 'expr_list' &&\r\n          astWhere.right.value.length === 2,\r\n        'BETWEEN needs 2 values in WHERE clause.'\r\n      );\r\n\r\n      queries = applyCondition(\r\n        queries,\r\n        astWhere.left.column,\r\n        '>=',\r\n        astWhere.right.value[0]\r\n      );\r\n      queries = applyCondition(\r\n        queries,\r\n        astWhere.left.column,\r\n        '<=',\r\n        astWhere.right.value[1]\r\n      );\r\n    } else {\r\n      assert(\r\n        astWhere.left.type === 'column_ref',\r\n        'Unsupported WHERE type on left side.'\r\n      );\r\n\r\n      queries = applyCondition(\r\n        queries,\r\n        astWhere.left.column,\r\n        astWhere.operator,\r\n        astWhere.right\r\n      );\r\n    }\r\n  } else if (astWhere.type === 'column_ref') {\r\n    // The query is like \"... WHERE column_name\", so lets return\r\n    // the documents where \"column_name\" is true. Ideally we would\r\n    // include any document where \"column_name\" is truthy, but there's\r\n    // no way to do that with Firestore.\r\n    queries = queries.map(query => query.where(astWhere.column, '==', true));\r\n  } else {\r\n    throw new Error('Unsupported WHERE clause');\r\n  }\r\n\r\n  return queries;\r\n}\r\n\r\nfunction applyCondition(\r\n  queries: firebase.firestore.Query[],\r\n  field: string,\r\n  astOperator: string,\r\n  astValue: SQL_Value\r\n): firebase.firestore.Query[] {\r\n  /*\r\n   TODO: Several things:\r\n\r\n    - If we're applying a range condition to a query (<, <=, >, >=)\r\n      we need to make sure that any other range condition on that same\r\n      query is only applied to the same field. Firestore doesn't\r\n      allow range conditions on several fields in the same query.\r\n\r\n    - If we apply a range condition, the first .orderBy() needs to\r\n      be on that same field. We should wait and only apply it if\r\n      the user has requested an ORDER BY. Otherwise, they might be\r\n      expecting the results ordered by document id.\r\n\r\n    - Can't combine \"LIKE 'value%'\" and inequality filters (>, <=, ...)\r\n      with AND:\r\n        SELECT * FROM shops WHERE rating > 2 AND name LIKE 'T%'\r\n      In theory it's only a problem when they're on the same field,\r\n      but since applying those on different fields doesn't make any\r\n      sense it's easier if we just disallow it in any case.\r\n      It's OK if it's with an OR (not the same query):\r\n        SELECT * FROM shops WHERE rating > 2 OR name LIKE 'T%'\r\n  */\r\n\r\n  if (astOperator === '!=' || astOperator === '<>') {\r\n    if (astValue.type === 'bool') {\r\n      // If the value is a boolean, then just perform a == operation\r\n      // with the negation of the value.\r\n      const negValue: SQL_ValueBool = { type: 'bool', value: !astValue.value };\r\n      return applyCondition(queries, field, '=', negValue);\r\n    } else {\r\n      // The != operator is not supported in Firestore so we\r\n      // split this query in two, one with the < operator and\r\n      // another one with the > operator.\r\n      return [\r\n        ...applyCondition(queries, field, '<', astValue),\r\n        ...applyCondition(queries, field, '>', astValue)\r\n      ];\r\n    }\r\n  } else {\r\n    const value = astValueToNative(astValue);\r\n    const operator = whereFilterOp(astOperator);\r\n    return queries.map(query => query.where(field, operator, value));\r\n  }\r\n}\r\n\r\nfunction whereFilterOp(op: string): firebase.firestore.WhereFilterOp {\r\n  let newOp: firebase.firestore.WhereFilterOp;\r\n\r\n  switch (op) {\r\n    case '=':\r\n    case 'IS':\r\n      newOp = '==';\r\n      break;\r\n    case '<':\r\n    case '<=':\r\n    case '>':\r\n    case '>=':\r\n      newOp = op;\r\n      break;\r\n    case 'CONTAINS':\r\n      // array-contains\r\n      throw new Error('\"CONTAINS\" WHERE operator unsupported');\r\n      break;\r\n    case 'NOT':\r\n    case 'NOT CONTAINS':\r\n      throw new Error('\"NOT\" WHERE operator unsupported');\r\n      break;\r\n    default:\r\n      throw new Error('Unknown WHERE operator');\r\n  }\r\n\r\n  return newOp;\r\n}\r\n\r\ninterface WhereLikeResult {\r\n  beginsWith?: SQL_ValueString;\r\n  endsWith?: SQL_ValueString;\r\n  contains?: SQL_ValueString;\r\n  equals?: SQL_ValueString;\r\n}\r\n\r\nfunction stringASTWhereValue(str: string): SQL_ValueString {\r\n  return {\r\n    type: 'string',\r\n    value: str\r\n  };\r\n}\r\n\r\nfunction parseWhereLike(str: string): WhereLikeResult {\r\n  const result: WhereLikeResult = {};\r\n  const strLength = str.length;\r\n\r\n  if (str[0] === '%') {\r\n    if (str[strLength - 1] === '%') {\r\n      result.contains = stringASTWhereValue(str.substr(1, strLength - 2));\r\n    } else {\r\n      result.endsWith = stringASTWhereValue(str.substring(1));\r\n    }\r\n  } else if (str[strLength - 1] === '%') {\r\n    result.beginsWith = stringASTWhereValue(str.substr(0, strLength - 1));\r\n  } else {\r\n    result.equals = stringASTWhereValue(str);\r\n  }\r\n\r\n  return result;\r\n}\r\n","import {\r\n  SQL_SelectColumn,\r\n  SQL_ColumnRef,\r\n  SQL_AggrFunction,\r\n  SQL_Select\r\n} from 'node-sqlparser';\r\nimport {\r\n  assert,\r\n  contains,\r\n  deepGet,\r\n  DocumentData,\r\n  safeGet,\r\n  nameOrAlias\r\n} from '../utils';\r\nimport {\r\n  applyGroupByLocally,\r\n  GroupedDocuments,\r\n  GroupAggregateValues,\r\n  DocumentsGroup\r\n} from './groupby';\r\nimport { applyOrderBy, applyOrderByLocally } from './orderby';\r\nimport { applyLimit, applyLimitLocally } from './limit';\r\nimport { applyWhere } from './where';\r\nimport { QueryOptions, DOCUMENT_KEY_NAME } from '../firesql';\r\n\r\nconst VALID_AGGR_FUNCTIONS = ['MIN', 'MAX', 'SUM', 'AVG'];\r\n\r\nexport async function select_(\r\n  ref: firebase.firestore.DocumentReference,\r\n  ast: SQL_Select,\r\n  options: QueryOptions\r\n): Promise<DocumentData[]> {\r\n  const selectOp = new SelectOperation(ref, ast, options);\r\n  const queries = selectOp.generateQueries_();\r\n  const documents = await selectOp.executeQueries_(queries);\r\n  return selectOp.processDocuments_(queries, documents);\r\n}\r\n\r\nexport class SelectOperation {\r\n  _includeId?: boolean | string;\r\n\r\n  constructor(\r\n    private _ref: firebase.firestore.DocumentReference,\r\n    private _ast: SQL_Select,\r\n    options: QueryOptions\r\n  ) {\r\n    // We need to determine if we have to include\r\n    // the document's ID (__name__) in the results.\r\n    this._includeId = options.includeId || false;\r\n    if (!this._includeId && Array.isArray(_ast.columns)) {\r\n      for (let i = 0; i < _ast.columns.length; i++) {\r\n        if (_ast.columns[i].expr.type === 'column_ref') {\r\n          if (\r\n            (_ast.columns[i].expr as SQL_ColumnRef).column === DOCUMENT_KEY_NAME\r\n          ) {\r\n            this._includeId = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this._includeId === void 0) {\r\n      this._includeId = false;\r\n    }\r\n  }\r\n\r\n  generateQueries_(ast?: SQL_Select): firebase.firestore.Query[] {\r\n    ast = ast || this._ast;\r\n\r\n    assert(\r\n      ast.from.length === 1,\r\n      'Only one collection at a time (no JOINs yet).'\r\n    );\r\n\r\n    const colName = ast.from[0].table;\r\n    let collection = this._ref.collection(colName);\r\n    let queries: firebase.firestore.Query[] = [collection];\r\n\r\n    /*\r\n   * We'd need this if we end up implementing JOINs, but for now\r\n   * it's unnecessary since we're only querying a single collection\r\n   \r\n    // Keep track of aliased \"tables\" (collections)\r\n    const aliasedCollections: { [k: string]: string } = {};\r\n    if (ast.from[0].as.length > 0) {\r\n      aliasedCollections[ast.from[0].as] = colName;\r\n    } else {\r\n      aliasedCollections[colName] = colName;\r\n    }\r\n   */\r\n\r\n    if (ast.where) {\r\n      queries = applyWhere(queries, ast.where);\r\n    }\r\n\r\n    if (ast.orderby) {\r\n      queries = applyOrderBy(queries, ast.orderby);\r\n\r\n      /*\r\n       FIXME: the following query throws an error:\r\n          SELECT city, name\r\n          FROM restaurants\r\n          WHERE city IN ('Nashvile', 'Denver')\r\n          ORDER BY city, name\r\n  \r\n       It happens because \"WHERE ... IN ...\" splits into 2 separate\r\n       queries with a \"==\" filter, and an order by clause cannot\r\n       contain a field with an equality filter:\r\n          ...where(\"city\",\"==\",\"Denver\").orderBy(\"city\")\r\n      */\r\n    }\r\n\r\n    // if (ast.groupby) {\r\n    //   throw new Error('GROUP BY not supported yet');\r\n    // }\r\n\r\n    if (ast.limit) {\r\n      // First we apply the limit to each query we may have\r\n      // and later we'll apply it again locally to the\r\n      // merged set of documents, in case we end up with too many.\r\n      queries = applyLimit(queries, ast.limit);\r\n    }\r\n\r\n    if (ast._next) {\r\n      assert(\r\n        ast._next.type === 'select',\r\n        ' UNION statements are only supported between SELECTs.'\r\n      );\r\n      // This is the UNION of 2 SELECTs, so lets process the second\r\n      // one and merge their queries\r\n      queries = queries.concat(this.generateQueries_(ast._next));\r\n\r\n      // FIXME: The SQL parser incorrectly attributes ORDER BY to the second\r\n      // SELECT only, instead of to the whole UNION. Find a workaround.\r\n    }\r\n\r\n    return queries;\r\n  }\r\n\r\n  async executeQueries_(\r\n    queries: firebase.firestore.Query[]\r\n  ): Promise<DocumentData[]> {\r\n    let documents: DocumentData[] = [];\r\n    const seenDocuments: { [id: string]: true } = {};\r\n\r\n    try {\r\n      await Promise.all(\r\n        queries.map(async query => {\r\n          const snapshot = await query.get();\r\n          const numDocs = snapshot.docs.length;\r\n\r\n          for (let i = 0; i < numDocs; i++) {\r\n            const docSnap = snapshot.docs[i];\r\n            const docPath = docSnap.ref.path;\r\n\r\n            if (!contains(seenDocuments, docPath)) {\r\n              const docData = docSnap.data();\r\n\r\n              if (this._includeId) {\r\n                docData[\r\n                  typeof this._includeId === 'string'\r\n                    ? this._includeId\r\n                    : DOCUMENT_KEY_NAME\r\n                ] = docSnap.id;\r\n              }\r\n\r\n              documents.push(docData);\r\n              seenDocuments[docPath] = true;\r\n            }\r\n          }\r\n        })\r\n      );\r\n    } catch (err) {\r\n      // TODO: handle error?\r\n      throw err;\r\n    }\r\n\r\n    return documents;\r\n  }\r\n\r\n  processDocuments_(\r\n    queries: firebase.firestore.Query[],\r\n    documents: DocumentData[]\r\n  ): DocumentData[] {\r\n    if (documents.length === 0) {\r\n      return [];\r\n    } else {\r\n      if (this._ast.groupby) {\r\n        const groupedDocs = applyGroupByLocally(documents, this._ast.groupby);\r\n        return this._processGroupedDocs(queries, groupedDocs);\r\n      } else {\r\n        return this._processUngroupedDocs(queries, documents);\r\n      }\r\n    }\r\n  }\r\n\r\n  private _processUngroupedDocs(\r\n    queries: firebase.firestore.Query[],\r\n    documents: DocumentData[]\r\n  ): DocumentData[] {\r\n    if (this._ast.orderby && queries.length > 1) {\r\n      // We merged more than one query into a single set of documents\r\n      // so we need to order the documents again, this time client-side.\r\n      documents = applyOrderByLocally(documents, this._ast.orderby);\r\n    }\r\n\r\n    if (this._ast.limit && queries.length > 1) {\r\n      // We merged more than one query into a single set of documents\r\n      // so we need to apply the limit again, this time client-side.\r\n      documents = applyLimitLocally(documents, this._ast.limit);\r\n    }\r\n\r\n    if (typeof this._ast.columns === 'string' && this._ast.columns === '*') {\r\n      // Return all fields from the documents\r\n    } else if (Array.isArray(this._ast.columns)) {\r\n      const aggrColumns = getAggrColumns(this._ast.columns);\r\n\r\n      if (aggrColumns.length > 0) {\r\n        const docsGroup = new DocumentsGroup();\r\n        docsGroup.documents = documents;\r\n        aggregateDocuments(docsGroup, aggrColumns);\r\n\r\n        /// Since there is no GROUP BY and we already computed all\r\n        // necessary aggregated values, at this point we only care\r\n        // about the first document in the list. Anything else is\r\n        // irrelevant.\r\n        const resultEntry = this._buildResultEntry(\r\n          docsGroup.documents[0],\r\n          docsGroup.aggr\r\n        );\r\n\r\n        documents = [resultEntry];\r\n      } else {\r\n        documents = documents.map(doc => this._buildResultEntry(doc));\r\n      }\r\n    } else {\r\n      // We should never reach here\r\n      throw new Error('Internal error (ast.columns).');\r\n    }\r\n\r\n    return documents;\r\n  }\r\n\r\n  private _processGroupedDocs(\r\n    queries: firebase.firestore.Query[],\r\n    groupedDocs: GroupedDocuments\r\n  ): DocumentData[] {\r\n    assert(this._ast.columns !== '*', 'Cannot \"SELECT *\" when using GROUP BY.');\r\n\r\n    const aggrColumns = getAggrColumns(this._ast.columns);\r\n    const groups = flattenGroupedDocs(groupedDocs);\r\n\r\n    if (aggrColumns.length === 0) {\r\n      // We're applying a GROUP BY but none of the fields requested\r\n      // in the SELECT are an aggregate function. In this case we\r\n      // just return an entry for the first document.\r\n      const firstGroupKey = Object.keys(groups)[0];\r\n      const firstGroup = groups[firstGroupKey];\r\n      const firstDoc = firstGroup.documents[0];\r\n      return [this._buildResultEntry(firstDoc)];\r\n    } else {\r\n      const results: DocumentData[] = [];\r\n\r\n      // TODO: ORDER BY\r\n      assert(\r\n        !this._ast.orderby,\r\n        'ORDER BY is not yet supported when using GROUP BY.'\r\n      );\r\n\r\n      // TODO: LIMIT\r\n      assert(\r\n        !this._ast.limit,\r\n        'LIMIT is not yet supported when using GROUP BY.'\r\n      );\r\n\r\n      Object.keys(groups).forEach(groupKey => {\r\n        const docsGroup = groups[groupKey];\r\n        aggregateDocuments(docsGroup, aggrColumns);\r\n\r\n        const resultEntry = this._buildResultEntry(\r\n          docsGroup.documents[0],\r\n          docsGroup.aggr\r\n        );\r\n\r\n        results.push(resultEntry);\r\n      });\r\n\r\n      return results;\r\n    }\r\n  }\r\n\r\n  private _buildResultEntry(\r\n    document: DocumentData,\r\n    aggregate?: GroupAggregateValues,\r\n    asFieldArray?: false\r\n  ): DocumentData;\r\n  private _buildResultEntry(\r\n    document: DocumentData,\r\n    aggregate?: GroupAggregateValues,\r\n    asFieldArray?: true\r\n  ): AliasedField[];\r\n  private _buildResultEntry(\r\n    document: DocumentData,\r\n    aggregate?: GroupAggregateValues,\r\n    asFieldArray = false\r\n  ): DocumentData | AliasedField[] {\r\n    let idIncluded = false;\r\n    const columns = this._ast.columns as SQL_SelectColumn[];\r\n\r\n    const resultFields: AliasedField[] = columns.reduce(\r\n      (entries: AliasedField[], column) => {\r\n        let fieldName: string;\r\n        let fieldAlias: string;\r\n\r\n        switch (column.expr.type) {\r\n          case 'column_ref':\r\n            fieldName = column.expr.column;\r\n            fieldAlias = nameOrAlias(fieldName, column.as);\r\n            entries.push(\r\n              new AliasedField(\r\n                fieldName,\r\n                fieldAlias,\r\n                deepGet(document, fieldName)\r\n              )\r\n            );\r\n            if (fieldName === DOCUMENT_KEY_NAME) {\r\n              idIncluded = true;\r\n            }\r\n            break;\r\n\r\n          case 'aggr_func':\r\n            vaidateAggrFunction(column.expr);\r\n            fieldName = (column.expr.args.expr as SQL_ColumnRef).column;\r\n            fieldAlias = nameOrAlias(fieldName, column.as, column.expr);\r\n            entries.push(\r\n              new AliasedField(\r\n                fieldName,\r\n                fieldAlias,\r\n                (aggregate! as any)[column.expr.name.toLowerCase()][fieldName]\r\n              )\r\n            );\r\n            break;\r\n\r\n          default:\r\n            throw new Error('Unsupported type in SELECT.');\r\n        }\r\n\r\n        return entries;\r\n      },\r\n      []\r\n    );\r\n\r\n    if (this._includeId && !idIncluded) {\r\n      resultFields.push(\r\n        new AliasedField(\r\n          DOCUMENT_KEY_NAME,\r\n          typeof this._includeId === 'string'\r\n            ? this._includeId\r\n            : DOCUMENT_KEY_NAME,\r\n          safeGet(document, DOCUMENT_KEY_NAME)\r\n        )\r\n      );\r\n    }\r\n\r\n    if (asFieldArray) {\r\n      return resultFields;\r\n    } else {\r\n      return resultFields.reduce((doc: DocumentData, field: AliasedField) => {\r\n        doc[field.alias] = field.value;\r\n        return doc;\r\n      }, {});\r\n    }\r\n  }\r\n}\r\n\r\n/*************************************************/\r\n\r\nfunction aggregateDocuments(\r\n  docsGroup: DocumentsGroup,\r\n  functions: SQL_AggrFunction[]\r\n): DocumentsGroup {\r\n  const numDocs = docsGroup.documents.length;\r\n\r\n  for (let i = 0; i < numDocs; i++) {\r\n    const doc = docsGroup.documents[i];\r\n\r\n    // If the same field is used in more than one aggregate function\r\n    // we don't want to sum its value more than once.\r\n    const skipSum: { [field: string]: true } = {};\r\n\r\n    functions.forEach(fn => {\r\n      const column = (fn.args.expr as SQL_ColumnRef).column;\r\n      let value = safeGet(doc, column);\r\n      const isNumber = !Number.isNaN(value);\r\n\r\n      switch (fn.name) {\r\n        case 'AVG':\r\n          // Lets put a value so that later we know we have to compute this avg\r\n          docsGroup.aggr.avg[column] = 0;\r\n        // tslint:disable-next-line:no-switch-case-fall-through\r\n        case 'SUM':\r\n          if (safeGet(skipSum, column) !== true) {\r\n            skipSum[column] = true;\r\n            if (!contains(docsGroup.aggr.total, column)) {\r\n              docsGroup.aggr.total[column] = 0;\r\n              docsGroup.aggr.sum[column] = 0;\r\n            }\r\n            value = Number(value);\r\n            assert(\r\n              !Number.isNaN(value),\r\n              `Can't compute aggregate function ${\r\n                fn.name\r\n              }(${column}) because some values are not numbers.`\r\n            );\r\n            docsGroup.aggr.total[column] += 1;\r\n            docsGroup.aggr.sum[column] += value;\r\n            // FIXME: if the numbers are big we could easily go out of bounds in this sum\r\n          }\r\n          break;\r\n        case 'MIN':\r\n          assert(\r\n            isNumber || typeof value === 'string',\r\n            `Aggregate function MIN(${column}) can only be performed on numbers or strings`\r\n          );\r\n          if (!contains(docsGroup.aggr.min, column)) {\r\n            docsGroup.aggr.min[column] = value;\r\n          } else {\r\n            if (!Number.isNaN(docsGroup.aggr.min[column] as any)) {\r\n              // The current minimum is a number\r\n              assert(\r\n                isNumber,\r\n                `Can't compute aggregate function MIN(${column}) because some values are not numbers.`\r\n              );\r\n              value = Number(value);\r\n            }\r\n            if (value < docsGroup.aggr.min[column]) {\r\n              docsGroup.aggr.min[column] = value;\r\n            }\r\n          }\r\n          break;\r\n        case 'MAX':\r\n          assert(\r\n            isNumber || typeof value === 'string',\r\n            `Aggregate function MAX(${column}) can only be performed on numbers or strings`\r\n          );\r\n          if (!contains(docsGroup.aggr.max, column)) {\r\n            docsGroup.aggr.max[column] = value;\r\n          } else {\r\n            if (!Number.isNaN(docsGroup.aggr.max[column] as any)) {\r\n              // The current maximum is a number\r\n              assert(\r\n                isNumber,\r\n                `Can't compute aggregate function MAX(${column}) because some values are not numbers.`\r\n              );\r\n              value = Number(value);\r\n            }\r\n            if (value > docsGroup.aggr.max[column]) {\r\n              docsGroup.aggr.max[column] = value;\r\n            }\r\n          }\r\n          break;\r\n      }\r\n    });\r\n  }\r\n\r\n  // Compute any necessary averages\r\n  Object.keys(docsGroup.aggr.avg).forEach(group => {\r\n    docsGroup.aggr.avg[group] =\r\n      docsGroup.aggr.sum[group] / docsGroup.aggr.total[group];\r\n  });\r\n\r\n  return docsGroup;\r\n}\r\n\r\nfunction getAggrColumns(columns: SQL_SelectColumn[] | '*'): SQL_AggrFunction[] {\r\n  const aggrColumns: SQL_AggrFunction[] = [];\r\n\r\n  if (columns !== '*') {\r\n    columns.forEach(astColumn => {\r\n      if (astColumn.expr.type === 'aggr_func') {\r\n        vaidateAggrFunction(astColumn.expr);\r\n        aggrColumns.push(astColumn.expr);\r\n      } else {\r\n        assert(\r\n          astColumn.expr.type === 'column_ref',\r\n          'Only field names and aggregate functions are supported in SELECT statements.'\r\n        );\r\n      }\r\n    });\r\n  }\r\n\r\n  return aggrColumns;\r\n}\r\n\r\nfunction vaidateAggrFunction(aggrFn: SQL_AggrFunction) {\r\n  // TODO: support COUNT, then remove this assert\r\n  assert(\r\n    aggrFn.name !== 'COUNT',\r\n    'Aggregate function COUNT is not yet supported.'\r\n  );\r\n\r\n  assert(\r\n    VALID_AGGR_FUNCTIONS.includes(aggrFn.name),\r\n    `Unknown aggregate function '${aggrFn.name}'.`\r\n  );\r\n\r\n  assert(\r\n    aggrFn.args.expr.type === 'column_ref',\r\n    `Unsupported type in aggregate function '${aggrFn.name}'.`\r\n  );\r\n}\r\n\r\nfunction flattenGroupedDocs(\r\n  groupedDocs: GroupedDocuments\r\n): { [k: string]: DocumentsGroup } {\r\n  let result: { [k: string]: any } = {};\r\n\r\n  for (let prop in groupedDocs) {\r\n    if (!contains(groupedDocs, prop)) {\r\n      continue;\r\n    }\r\n\r\n    if (!(groupedDocs[prop] instanceof DocumentsGroup)) {\r\n      let flatInner = flattenGroupedDocs(groupedDocs[prop] as GroupedDocuments);\r\n\r\n      for (let innerProp in flatInner) {\r\n        if (!contains(flatInner, innerProp)) {\r\n          continue;\r\n        }\r\n        result[prop + '$$' + innerProp] = flatInner[innerProp];\r\n      }\r\n    } else {\r\n      result[prop] = groupedDocs[prop];\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Represents a field (prop) in a document.\r\n * It stores the original field name, the assigned alias, and the value.\r\n *\r\n * This is necessary in order to properly apply ORDER BY once\r\n * a result set has been built.\r\n */\r\nclass AliasedField {\r\n  constructor(public name: string, public alias: string, public value: any) {}\r\n}\r\n","import { parse as parseSQL } from 'node-sqlparser';\r\nimport firebase from 'firebase/app';\r\nimport 'firebase/firestore';\r\nimport { DocumentData, assert } from './utils';\r\nimport { select_ } from './select';\r\n\r\n// Polyfills\r\nimport 'core-js';\r\n\r\nexport const DOCUMENT_KEY_NAME = '__name__';\r\n\r\nexport class FireSQL {\r\n  private _ref?: firebase.firestore.DocumentReference;\r\n  private _path?: string;\r\n  private _options: FireSQLOptions;\r\n\r\n  constructor(\r\n    refOrOptions?: FirestoreOrDocOrOptions,\r\n    options?: FireSQLOptions\r\n  ) {\r\n    this._options = options as FireSQLOptions;\r\n\r\n    if (typeof refOrOptions === 'object') {\r\n      if (refOrOptions instanceof firebase.firestore.DocumentReference) {\r\n        this._ref = refOrOptions as firebase.firestore.DocumentReference;\r\n      } else if (refOrOptions instanceof firebase.firestore.Firestore) {\r\n        this._ref = (refOrOptions as firebase.firestore.Firestore).doc('/');\r\n      } else if (!options) {\r\n        this._options = refOrOptions as FireSQLOptions;\r\n      } else {\r\n        throw new Error(\r\n          'With options as the second parameter, the first parameter ' +\r\n            'needs to be a path string or a Firestore reference.'\r\n        );\r\n      }\r\n    } else {\r\n      if (typeof refOrOptions === 'string') {\r\n        this._path = refOrOptions;\r\n      }\r\n    }\r\n\r\n    if (!this._options) {\r\n      this._options = options || {};\r\n    }\r\n\r\n    if (!this._ref) {\r\n      try {\r\n        this._getRef();\r\n      } catch (err) {\r\n        // The default Firebase app hasn't been initialized yet.\r\n        // No problem, we'll try again when the user launches\r\n        // the first query.\r\n      }\r\n    }\r\n  }\r\n\r\n  get ref(): firebase.firestore.DocumentReference {\r\n    return this._getRef();\r\n  }\r\n\r\n  get firestore(): firebase.firestore.Firestore {\r\n    return this._getRef().firestore;\r\n  }\r\n\r\n  get options(): FireSQLOptions {\r\n    return this._options;\r\n  }\r\n\r\n  query(sql: string, options?: QueryOptions): Promise<DocumentData[]>;\r\n  query<T>(sql: string, options?: QueryOptions): Promise<T[]>;\r\n  async query<T>(\r\n    sql: string,\r\n    options: QueryOptions = {}\r\n  ): Promise<T[] | DocumentData[]> {\r\n    assert(\r\n      typeof sql === 'string' && sql.length > 0,\r\n      'query() expects a non-empty string.'\r\n    );\r\n    const ast = parseSQL(sql);\r\n\r\n    if (ast.type === 'select') {\r\n      return select_(this._getRef(), ast, { ...this._options, ...options });\r\n    } else {\r\n      throw new Error(\r\n        `\"${(ast.type as string).toUpperCase()}\" statements are not supported.`\r\n      );\r\n    }\r\n  }\r\n\r\n  private _getRef(): firebase.firestore.DocumentReference {\r\n    if (!this._ref) {\r\n      try {\r\n        const firestore = firebase.firestore();\r\n        this._ref = firestore.doc(this._path !== void 0 ? this._path : '/');\r\n        delete this._path;\r\n      } catch (err) {\r\n        console.error(err);\r\n        throw new Error(\r\n          'The default Firebase app has not been initialized yet.'\r\n        );\r\n      }\r\n    }\r\n\r\n    return this._ref;\r\n  }\r\n\r\n  toJSON(): object {\r\n    return {\r\n      ref: this._getRef(),\r\n      options: this._options\r\n    };\r\n  }\r\n}\r\n\r\nexport interface FireSQLOptions {\r\n  includeId?: boolean | string;\r\n}\r\n\r\nexport interface QueryOptions extends FireSQLOptions {}\r\n\r\nexport type FirestoreOrDocument =\r\n  | string\r\n  | firebase.firestore.Firestore\r\n  | firebase.firestore.DocumentReference;\r\n\r\nexport type FirestoreOrDocOrOptions = FirestoreOrDocument | FireSQLOptions;\r\n\r\n/**\r\n * @deprecated Class FirestoreSQL has been renamed FireSQL\r\n */\r\nexport class FirestoreSQL extends FireSQL {\r\n  constructor(\r\n    ref?:\r\n      | string\r\n      | firebase.firestore.Firestore\r\n      | firebase.firestore.DocumentReference\r\n  ) {\r\n    console.warn(\r\n      'DEPRECATED: Class FirestoreSQL has been renamed FireSQL.\\n' +\r\n        'Using \"FirestoreSQL\" will stop working in future releases, update your code accordingly.'\r\n    );\r\n    super(ref);\r\n  }\r\n}\r\n","import { parse as parseSQL, SQL_Select } from 'node-sqlparser';\r\nimport { Observable, combineLatest } from 'rxjs';\r\nimport { map } from 'rxjs/operators';\r\nimport { collectionData } from 'rxfire/firestore';\r\nimport { FireSQL, QueryOptions, DOCUMENT_KEY_NAME } from '../firesql';\r\nimport { SelectOperation } from '../select';\r\nimport { assert, DocumentData, contains } from '../utils';\r\n\r\ndeclare module '../firesql' {\r\n  interface FireSQL {\r\n    rxQuery(sql: string, options?: QueryOptions): Observable<DocumentData[]>;\r\n    rxQuery<T>(sql: string, options?: QueryOptions): Observable<T[]>;\r\n  }\r\n\r\n  /**\r\n   * @deprecated\r\n   */\r\n  interface FirestoreSQL {\r\n    rxQuery(sql: string, options?: QueryOptions): Observable<DocumentData[]>;\r\n    rxQuery<T>(sql: string, options?: QueryOptions): Observable<T[]>;\r\n  }\r\n}\r\n\r\nFireSQL.prototype.rxQuery = function<T>(\r\n  sql: string,\r\n  options?: QueryOptions\r\n): Observable<T[] | DocumentData[]> {\r\n  assert(\r\n    typeof sql === 'string' && sql.length > 0,\r\n    'rxQuery() expects a non-empty string.'\r\n  );\r\n  const ast = parseSQL(sql);\r\n  assert(ast.type === 'select', 'Only SELECT statements are supported.');\r\n  return rxSelect((this as any)._getRef(), ast, {\r\n    ...(this as any)._options,\r\n    ...options\r\n  });\r\n};\r\n\r\nfunction rxSelect(\r\n  ref: firebase.firestore.DocumentReference,\r\n  ast: SQL_Select,\r\n  options: QueryOptions\r\n): Observable<firebase.firestore.DocumentData[]> {\r\n  const selectOp = new SelectOperation(ref, ast, options);\r\n  let queries = selectOp.generateQueries_();\r\n\r\n  if (ast._next) {\r\n    assert(\r\n      ast._next.type === 'select',\r\n      ' UNION statements are only supported between SELECTs.'\r\n    );\r\n    // This is the UNION of 2 SELECTs, so lets process the second\r\n    // one and merge their queries\r\n    queries = queries.concat(selectOp.generateQueries_(ast._next));\r\n\r\n    // FIXME: The SQL parser incorrectly attributes ORDER BY to the second\r\n    // SELECT only, instead of to the whole UNION. Find a workaround.\r\n  }\r\n\r\n  let idField: string;\r\n  let keepIdField: boolean;\r\n\r\n  if (selectOp._includeId === true) {\r\n    idField = DOCUMENT_KEY_NAME;\r\n    keepIdField = true;\r\n  } else if (typeof selectOp._includeId === 'string') {\r\n    idField = selectOp._includeId;\r\n    keepIdField = true;\r\n  } else {\r\n    idField = DOCUMENT_KEY_NAME;\r\n    keepIdField = false;\r\n  }\r\n\r\n  const rxData = combineLatest(\r\n    queries.map(query => collectionData(query, idField))\r\n  );\r\n\r\n  return rxData.pipe(\r\n    map((results: firebase.firestore.DocumentData[][]) => {\r\n      // We have an array of results (one for each query we generated) where\r\n      // each element is an array of documents. We need to flatten them.\r\n      const documents: firebase.firestore.DocumentData[] = [];\r\n      const seenDocuments: { [id: string]: true } = {};\r\n\r\n      for (const docs of results) {\r\n        for (const doc of docs) {\r\n          // Note: for now we're only allowing to query a single collection, but\r\n          // if at any point we change that (for example with JOINs) we'll need to\r\n          // use the full document path here instead of just its ID\r\n          if (!contains(seenDocuments, doc[idField])) {\r\n            seenDocuments[doc[idField]] = true;\r\n            if (!keepIdField) {\r\n              delete doc[idField];\r\n            }\r\n            documents.push(doc);\r\n          }\r\n        }\r\n      }\r\n\r\n      return documents;\r\n    }),\r\n    map((documents: firebase.firestore.DocumentData[]) => {\r\n      return selectOp.processDocuments_(queries, documents);\r\n    })\r\n  );\r\n}\r\n"],"names":["parseSQL","tslib_1.__extends"],"mappings":"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"}