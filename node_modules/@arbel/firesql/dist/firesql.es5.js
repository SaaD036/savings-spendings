import { parse } from 'node-sqlparser';
import firebase from 'firebase/app';
import 'firebase/firestore';
import 'core-js';
import { combineLatest } from 'rxjs';
import { map } from 'rxjs/operators';
import { collectionData } from 'rxfire/firestore';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function assert(condition, message) {
    if (!condition) {
        throw new Error(message);
    }
}
function contains(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
function safeGet(obj, prop) {
    if (contains(obj, prop))
        return obj[prop];
}
function deepGet(obj, path) {
    var value = obj;
    var props = path.split('.');
    props.some(function (prop) {
        value = safeGet(value, prop);
        // By using "some" instead of "forEach", we can return
        // true whenever we want to break out of the loop.
        return typeof value === void 0;
    });
    return value;
}
function astValueToNative(astValue) {
    var value;
    switch (astValue.type) {
        case 'bool':
        case 'null':
        case 'string':
            value = astValue.value;
            break;
        case 'number':
            value = Number(astValue.value);
            break;
        default:
            throw new Error('Unsupported value type in WHERE clause.');
    }
    return value;
}
/**
 * Adapted from: https://github.com/firebase/firebase-ios-sdk/blob/14dd9dc2704038c3bf702426439683cee4dc941a/Firestore/core/src/firebase/firestore/util/string_util.cc#L23-L40
 */
function prefixSuccessor(prefix) {
    // We can increment the last character in the string and be done
    // unless that character is 255 (0xff), in which case we have to erase the
    // last character and increment the previous character, unless that
    // is 255, etc. If the string is empty or consists entirely of
    // 255's, we just return the empty string.
    var limit = prefix;
    while (limit.length > 0) {
        var index = limit.length - 1;
        if (limit[index] === '\xff') {
            limit = limit.slice(0, -1);
        }
        else {
            limit =
                limit.substr(0, index) +
                    String.fromCharCode(limit.charCodeAt(index) + 1);
            break;
        }
    }
    return limit;
}
function nameOrAlias(name, alias, aggrFn) {
    if (alias !== null && alias.length > 0) {
        return alias;
    }
    if (!aggrFn) {
        return name;
    }
    return aggrFn.name + "(" + name + ")";
}

function applyGroupByLocally(documents, astGroupBy) {
    assert(astGroupBy.length > 0, 'GROUP BY needs at least 1 group.');
    var group = new DocumentsGroup();
    group.documents = documents;
    astGroupBy.forEach(function (groupBy) {
        assert(groupBy.type === 'column_ref', 'GROUP BY only supports grouping by field names.');
        group = applySingleGroupBy(group, groupBy);
    });
    return group;
}
function applySingleGroupBy(documents, groupBy) {
    var groupedDocs = {};
    if (documents instanceof DocumentsGroup) {
        // We just have a list of documents
        var numDocs = documents.documents.length;
        for (var i = 0; i < numDocs; i++) {
            var doc = documents.documents[i];
            // Since we're going to use the value as an object key, always
            // coherce it to a string in case it's some other type.
            var groupValue = String(safeGet(doc, groupBy.column));
            if (!contains(groupedDocs, groupValue)) {
                groupedDocs[groupValue] = new DocumentsGroup();
            }
            groupedDocs[groupValue].documents.push(doc);
        }
        return groupedDocs;
    }
    else {
        // We have documents that have already been grouped with another field
        var currentGroups = Object.keys(documents);
        currentGroups.forEach(function (group) {
            groupedDocs[group] = applySingleGroupBy(documents[group], groupBy);
        });
        return groupedDocs;
    }
}
var DocumentsGroup = /** @class */ (function () {
    function DocumentsGroup(key) {
        this.key = key;
        this.documents = [];
        this.aggr = {
            sum: {},
            avg: {},
            min: {},
            max: {},
            total: {}
        };
    }
    return DocumentsGroup;
}());

function applyOrderBy(queries, astOrderBy) {
    astOrderBy.forEach(function (orderBy) {
        assert(orderBy.expr.type === 'column_ref', 'ORDER BY only supports ordering by field names.');
        queries = queries.map(function (query) {
            return query.orderBy(orderBy.expr.column, orderBy.type.toLowerCase());
        });
    });
    return queries;
}
function applyOrderByLocally(docs, astOrderBy) {
    return docs.sort(function (doc1, doc2) {
        return astOrderBy.reduce(function (result, orderBy) {
            if (result !== 0) {
                // We already found a way to sort these 2 documents, so there's
                // no need to keep going. This doesn't actually break out of the
                // reducer but prevents doing any further unnecessary and
                // potentially expensive comparisons.
                return result;
            }
            var field = orderBy.expr.column;
            if (doc1[field] < doc2[field]) {
                result = -1;
            }
            else if (doc1[field] > doc2[field]) {
                result = 1;
            }
            else {
                result = 0;
            }
            if (orderBy.type === 'DESC' && result !== 0) {
                result = -result;
            }
            return result;
        }, 0);
    });
}

function applyLimit(queries, astLimit) {
    // node-sqlparser's implementation of LIMIT is a bit buggy.
    // If limit and offset are passed, it returns an array where
    // the first item is the limit and the second one is the
    // offset, but if no offset is specified then the first item
    // in the array is the number 0 and the second one contains
    // the actual limit.
    // Plus, it throws an error if there's a newline character
    // following the limit.
    assert(astLimit[0].value === 0, "LIMIT doesn't support specifying an OFFSET.");
    var limit = astValueToNative(astLimit[1]);
    return queries.map(function (query) { return query.limit(limit); });
}
function applyLimitLocally(docs, astLimit) {
    var limit = astValueToNative(astLimit[1]);
    docs.splice(limit);
    return docs;
}

function applyWhere(queries, astWhere) {
    if (astWhere.type === 'binary_expr') {
        if (astWhere.operator === 'AND') {
            queries = applyWhere(queries, astWhere.left);
            queries = applyWhere(queries, astWhere.right);
        }
        else if (astWhere.operator === 'OR') {
            queries = applyWhere(queries, astWhere.left).concat(applyWhere(queries, astWhere.right));
        }
        else if (astWhere.operator === 'IN') {
            assert(astWhere.left.type === 'column_ref', 'Unsupported WHERE type on left side.');
            assert(astWhere.right.type === 'expr_list', 'Unsupported WHERE type on right side.');
            var newQueries_1 = [];
            astWhere.right.value.forEach(function (valueObj) {
                newQueries_1.push.apply(newQueries_1, applyCondition(queries, astWhere.left.column, '=', valueObj));
            });
            queries = newQueries_1;
        }
        else if (astWhere.operator === 'LIKE') {
            assert(astWhere.left.type === 'column_ref', 'Unsupported WHERE type on left side.');
            assert(astWhere.right.type === 'string', 'Only strings are supported with LIKE in WHERE clause.');
            var whereLike = parseWhereLike(astWhere.right.value);
            if (whereLike.equals !== void 0) {
                queries = applyCondition(queries, astWhere.left.column, '=', whereLike.equals);
            }
            else if (whereLike.beginsWith !== void 0) {
                var successorStr = prefixSuccessor(whereLike.beginsWith.value);
                queries = applyCondition(queries, astWhere.left.column, '>=', whereLike.beginsWith);
                queries = applyCondition(queries, astWhere.left.column, '<', stringASTWhereValue(successorStr));
            }
            else {
                throw new Error('Only terms in the form of "value%" (string begins with value) and "value" (string equals value) are supported with LIKE in WHERE clause.');
            }
        }
        else if (astWhere.operator === 'BETWEEN') {
            assert(astWhere.left.type === 'column_ref', 'Unsupported WHERE type on left side.');
            assert(astWhere.right.type === 'expr_list' &&
                astWhere.right.value.length === 2, 'BETWEEN needs 2 values in WHERE clause.');
            queries = applyCondition(queries, astWhere.left.column, '>=', astWhere.right.value[0]);
            queries = applyCondition(queries, astWhere.left.column, '<=', astWhere.right.value[1]);
        }
        else {
            assert(astWhere.left.type === 'column_ref', 'Unsupported WHERE type on left side.');
            queries = applyCondition(queries, astWhere.left.column, astWhere.operator, astWhere.right);
        }
    }
    else if (astWhere.type === 'column_ref') {
        // The query is like "... WHERE column_name", so lets return
        // the documents where "column_name" is true. Ideally we would
        // include any document where "column_name" is truthy, but there's
        // no way to do that with Firestore.
        queries = queries.map(function (query) { return query.where(astWhere.column, '==', true); });
    }
    else {
        throw new Error('Unsupported WHERE clause');
    }
    return queries;
}
function applyCondition(queries, field, astOperator, astValue) {
    /*
     TODO: Several things:
  
      - If we're applying a range condition to a query (<, <=, >, >=)
        we need to make sure that any other range condition on that same
        query is only applied to the same field. Firestore doesn't
        allow range conditions on several fields in the same query.
  
      - If we apply a range condition, the first .orderBy() needs to
        be on that same field. We should wait and only apply it if
        the user has requested an ORDER BY. Otherwise, they might be
        expecting the results ordered by document id.
  
      - Can't combine "LIKE 'value%'" and inequality filters (>, <=, ...)
        with AND:
          SELECT * FROM shops WHERE rating > 2 AND name LIKE 'T%'
        In theory it's only a problem when they're on the same field,
        but since applying those on different fields doesn't make any
        sense it's easier if we just disallow it in any case.
        It's OK if it's with an OR (not the same query):
          SELECT * FROM shops WHERE rating > 2 OR name LIKE 'T%'
    */
    if (astOperator === '!=' || astOperator === '<>') {
        if (astValue.type === 'bool') {
            // If the value is a boolean, then just perform a == operation
            // with the negation of the value.
            var negValue = { type: 'bool', value: !astValue.value };
            return applyCondition(queries, field, '=', negValue);
        }
        else {
            // The != operator is not supported in Firestore so we
            // split this query in two, one with the < operator and
            // another one with the > operator.
            return applyCondition(queries, field, '<', astValue).concat(applyCondition(queries, field, '>', astValue));
        }
    }
    else {
        var value_1 = astValueToNative(astValue);
        var operator_1 = whereFilterOp(astOperator);
        return queries.map(function (query) { return query.where(field, operator_1, value_1); });
    }
}
function whereFilterOp(op) {
    var newOp;
    switch (op) {
        case '=':
        case 'IS':
            newOp = '==';
            break;
        case '<':
        case '<=':
        case '>':
        case '>=':
            newOp = op;
            break;
        case 'CONTAINS':
            // array-contains
            throw new Error('"CONTAINS" WHERE operator unsupported');
            break;
        case 'NOT':
        case 'NOT CONTAINS':
            throw new Error('"NOT" WHERE operator unsupported');
            break;
        default:
            throw new Error('Unknown WHERE operator');
    }
    return newOp;
}
function stringASTWhereValue(str) {
    return {
        type: 'string',
        value: str
    };
}
function parseWhereLike(str) {
    var result = {};
    var strLength = str.length;
    if (str[0] === '%') {
        if (str[strLength - 1] === '%') {
            result.contains = stringASTWhereValue(str.substr(1, strLength - 2));
        }
        else {
            result.endsWith = stringASTWhereValue(str.substring(1));
        }
    }
    else if (str[strLength - 1] === '%') {
        result.beginsWith = stringASTWhereValue(str.substr(0, strLength - 1));
    }
    else {
        result.equals = stringASTWhereValue(str);
    }
    return result;
}

var VALID_AGGR_FUNCTIONS = ['MIN', 'MAX', 'SUM', 'AVG'];
function select_(ref, ast, options) {
    return __awaiter(this, void 0, void 0, function () {
        var selectOp, queries, documents;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    selectOp = new SelectOperation(ref, ast, options);
                    queries = selectOp.generateQueries_();
                    return [4 /*yield*/, selectOp.executeQueries_(queries)];
                case 1:
                    documents = _a.sent();
                    return [2 /*return*/, selectOp.processDocuments_(queries, documents)];
            }
        });
    });
}
var SelectOperation = /** @class */ (function () {
    function SelectOperation(_ref, _ast, options) {
        this._ref = _ref;
        this._ast = _ast;
        // We need to determine if we have to include
        // the document's ID (__name__) in the results.
        this._includeId = options.includeId || false;
        if (!this._includeId && Array.isArray(_ast.columns)) {
            for (var i = 0; i < _ast.columns.length; i++) {
                if (_ast.columns[i].expr.type === 'column_ref') {
                    if (_ast.columns[i].expr.column === DOCUMENT_KEY_NAME) {
                        this._includeId = true;
                        break;
                    }
                }
            }
        }
        if (this._includeId === void 0) {
            this._includeId = false;
        }
    }
    SelectOperation.prototype.generateQueries_ = function (ast) {
        ast = ast || this._ast;
        assert(ast.from.length === 1, 'Only one collection at a time (no JOINs yet).');
        var colName = ast.from[0].table;
        var collection = this._ref.collection(colName);
        var queries = [collection];
        /*
       * We'd need this if we end up implementing JOINs, but for now
       * it's unnecessary since we're only querying a single collection
       
        // Keep track of aliased "tables" (collections)
        const aliasedCollections: { [k: string]: string } = {};
        if (ast.from[0].as.length > 0) {
          aliasedCollections[ast.from[0].as] = colName;
        } else {
          aliasedCollections[colName] = colName;
        }
       */
        if (ast.where) {
            queries = applyWhere(queries, ast.where);
        }
        if (ast.orderby) {
            queries = applyOrderBy(queries, ast.orderby);
            /*
             FIXME: the following query throws an error:
                SELECT city, name
                FROM restaurants
                WHERE city IN ('Nashvile', 'Denver')
                ORDER BY city, name
        
             It happens because "WHERE ... IN ..." splits into 2 separate
             queries with a "==" filter, and an order by clause cannot
             contain a field with an equality filter:
                ...where("city","==","Denver").orderBy("city")
            */
        }
        // if (ast.groupby) {
        //   throw new Error('GROUP BY not supported yet');
        // }
        if (ast.limit) {
            // First we apply the limit to each query we may have
            // and later we'll apply it again locally to the
            // merged set of documents, in case we end up with too many.
            queries = applyLimit(queries, ast.limit);
        }
        if (ast._next) {
            assert(ast._next.type === 'select', ' UNION statements are only supported between SELECTs.');
            // This is the UNION of 2 SELECTs, so lets process the second
            // one and merge their queries
            queries = queries.concat(this.generateQueries_(ast._next));
            // FIXME: The SQL parser incorrectly attributes ORDER BY to the second
            // SELECT only, instead of to the whole UNION. Find a workaround.
        }
        return queries;
    };
    SelectOperation.prototype.executeQueries_ = function (queries) {
        return __awaiter(this, void 0, void 0, function () {
            var documents, seenDocuments, err_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        documents = [];
                        seenDocuments = {};
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, Promise.all(queries.map(function (query) { return __awaiter(_this, void 0, void 0, function () {
                                var snapshot, numDocs, i, docSnap, docPath, docData;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, query.get()];
                                        case 1:
                                            snapshot = _a.sent();
                                            numDocs = snapshot.docs.length;
                                            for (i = 0; i < numDocs; i++) {
                                                docSnap = snapshot.docs[i];
                                                docPath = docSnap.ref.path;
                                                if (!contains(seenDocuments, docPath)) {
                                                    docData = docSnap.data();
                                                    if (this._includeId) {
                                                        docData[typeof this._includeId === 'string'
                                                            ? this._includeId
                                                            : DOCUMENT_KEY_NAME] = docSnap.id;
                                                    }
                                                    documents.push(docData);
                                                    seenDocuments[docPath] = true;
                                                }
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); }))];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        // TODO: handle error?
                        throw err_1;
                    case 4: return [2 /*return*/, documents];
                }
            });
        });
    };
    SelectOperation.prototype.processDocuments_ = function (queries, documents) {
        if (documents.length === 0) {
            return [];
        }
        else {
            if (this._ast.groupby) {
                var groupedDocs = applyGroupByLocally(documents, this._ast.groupby);
                return this._processGroupedDocs(queries, groupedDocs);
            }
            else {
                return this._processUngroupedDocs(queries, documents);
            }
        }
    };
    SelectOperation.prototype._processUngroupedDocs = function (queries, documents) {
        var _this = this;
        if (this._ast.orderby && queries.length > 1) {
            // We merged more than one query into a single set of documents
            // so we need to order the documents again, this time client-side.
            documents = applyOrderByLocally(documents, this._ast.orderby);
        }
        if (this._ast.limit && queries.length > 1) {
            // We merged more than one query into a single set of documents
            // so we need to apply the limit again, this time client-side.
            documents = applyLimitLocally(documents, this._ast.limit);
        }
        if (typeof this._ast.columns === 'string' && this._ast.columns === '*') ;
        else if (Array.isArray(this._ast.columns)) {
            var aggrColumns = getAggrColumns(this._ast.columns);
            if (aggrColumns.length > 0) {
                var docsGroup = new DocumentsGroup();
                docsGroup.documents = documents;
                aggregateDocuments(docsGroup, aggrColumns);
                /// Since there is no GROUP BY and we already computed all
                // necessary aggregated values, at this point we only care
                // about the first document in the list. Anything else is
                // irrelevant.
                var resultEntry = this._buildResultEntry(docsGroup.documents[0], docsGroup.aggr);
                documents = [resultEntry];
            }
            else {
                documents = documents.map(function (doc) { return _this._buildResultEntry(doc); });
            }
        }
        else {
            // We should never reach here
            throw new Error('Internal error (ast.columns).');
        }
        return documents;
    };
    SelectOperation.prototype._processGroupedDocs = function (queries, groupedDocs) {
        var _this = this;
        assert(this._ast.columns !== '*', 'Cannot "SELECT *" when using GROUP BY.');
        var aggrColumns = getAggrColumns(this._ast.columns);
        var groups = flattenGroupedDocs(groupedDocs);
        if (aggrColumns.length === 0) {
            // We're applying a GROUP BY but none of the fields requested
            // in the SELECT are an aggregate function. In this case we
            // just return an entry for the first document.
            var firstGroupKey = Object.keys(groups)[0];
            var firstGroup = groups[firstGroupKey];
            var firstDoc = firstGroup.documents[0];
            return [this._buildResultEntry(firstDoc)];
        }
        else {
            var results_1 = [];
            // TODO: ORDER BY
            assert(!this._ast.orderby, 'ORDER BY is not yet supported when using GROUP BY.');
            // TODO: LIMIT
            assert(!this._ast.limit, 'LIMIT is not yet supported when using GROUP BY.');
            Object.keys(groups).forEach(function (groupKey) {
                var docsGroup = groups[groupKey];
                aggregateDocuments(docsGroup, aggrColumns);
                var resultEntry = _this._buildResultEntry(docsGroup.documents[0], docsGroup.aggr);
                results_1.push(resultEntry);
            });
            return results_1;
        }
    };
    SelectOperation.prototype._buildResultEntry = function (document, aggregate, asFieldArray) {
        if (asFieldArray === void 0) { asFieldArray = false; }
        var idIncluded = false;
        var columns = this._ast.columns;
        var resultFields = columns.reduce(function (entries, column) {
            var fieldName;
            var fieldAlias;
            switch (column.expr.type) {
                case 'column_ref':
                    fieldName = column.expr.column;
                    fieldAlias = nameOrAlias(fieldName, column.as);
                    entries.push(new AliasedField(fieldName, fieldAlias, deepGet(document, fieldName)));
                    if (fieldName === DOCUMENT_KEY_NAME) {
                        idIncluded = true;
                    }
                    break;
                case 'aggr_func':
                    vaidateAggrFunction(column.expr);
                    fieldName = column.expr.args.expr.column;
                    fieldAlias = nameOrAlias(fieldName, column.as, column.expr);
                    entries.push(new AliasedField(fieldName, fieldAlias, aggregate[column.expr.name.toLowerCase()][fieldName]));
                    break;
                default:
                    throw new Error('Unsupported type in SELECT.');
            }
            return entries;
        }, []);
        if (this._includeId && !idIncluded) {
            resultFields.push(new AliasedField(DOCUMENT_KEY_NAME, typeof this._includeId === 'string'
                ? this._includeId
                : DOCUMENT_KEY_NAME, safeGet(document, DOCUMENT_KEY_NAME)));
        }
        if (asFieldArray) {
            return resultFields;
        }
        else {
            return resultFields.reduce(function (doc, field) {
                doc[field.alias] = field.value;
                return doc;
            }, {});
        }
    };
    return SelectOperation;
}());
/*************************************************/
function aggregateDocuments(docsGroup, functions) {
    var numDocs = docsGroup.documents.length;
    var _loop_1 = function (i) {
        var doc = docsGroup.documents[i];
        // If the same field is used in more than one aggregate function
        // we don't want to sum its value more than once.
        var skipSum = {};
        functions.forEach(function (fn) {
            var column = fn.args.expr.column;
            var value = safeGet(doc, column);
            var isNumber = !Number.isNaN(value);
            switch (fn.name) {
                case 'AVG':
                    // Lets put a value so that later we know we have to compute this avg
                    docsGroup.aggr.avg[column] = 0;
                // tslint:disable-next-line:no-switch-case-fall-through
                case 'SUM':
                    if (safeGet(skipSum, column) !== true) {
                        skipSum[column] = true;
                        if (!contains(docsGroup.aggr.total, column)) {
                            docsGroup.aggr.total[column] = 0;
                            docsGroup.aggr.sum[column] = 0;
                        }
                        value = Number(value);
                        assert(!Number.isNaN(value), "Can't compute aggregate function " + fn.name + "(" + column + ") because some values are not numbers.");
                        docsGroup.aggr.total[column] += 1;
                        docsGroup.aggr.sum[column] += value;
                        // FIXME: if the numbers are big we could easily go out of bounds in this sum
                    }
                    break;
                case 'MIN':
                    assert(isNumber || typeof value === 'string', "Aggregate function MIN(" + column + ") can only be performed on numbers or strings");
                    if (!contains(docsGroup.aggr.min, column)) {
                        docsGroup.aggr.min[column] = value;
                    }
                    else {
                        if (!Number.isNaN(docsGroup.aggr.min[column])) {
                            // The current minimum is a number
                            assert(isNumber, "Can't compute aggregate function MIN(" + column + ") because some values are not numbers.");
                            value = Number(value);
                        }
                        if (value < docsGroup.aggr.min[column]) {
                            docsGroup.aggr.min[column] = value;
                        }
                    }
                    break;
                case 'MAX':
                    assert(isNumber || typeof value === 'string', "Aggregate function MAX(" + column + ") can only be performed on numbers or strings");
                    if (!contains(docsGroup.aggr.max, column)) {
                        docsGroup.aggr.max[column] = value;
                    }
                    else {
                        if (!Number.isNaN(docsGroup.aggr.max[column])) {
                            // The current maximum is a number
                            assert(isNumber, "Can't compute aggregate function MAX(" + column + ") because some values are not numbers.");
                            value = Number(value);
                        }
                        if (value > docsGroup.aggr.max[column]) {
                            docsGroup.aggr.max[column] = value;
                        }
                    }
                    break;
            }
        });
    };
    for (var i = 0; i < numDocs; i++) {
        _loop_1(i);
    }
    // Compute any necessary averages
    Object.keys(docsGroup.aggr.avg).forEach(function (group) {
        docsGroup.aggr.avg[group] =
            docsGroup.aggr.sum[group] / docsGroup.aggr.total[group];
    });
    return docsGroup;
}
function getAggrColumns(columns) {
    var aggrColumns = [];
    if (columns !== '*') {
        columns.forEach(function (astColumn) {
            if (astColumn.expr.type === 'aggr_func') {
                vaidateAggrFunction(astColumn.expr);
                aggrColumns.push(astColumn.expr);
            }
            else {
                assert(astColumn.expr.type === 'column_ref', 'Only field names and aggregate functions are supported in SELECT statements.');
            }
        });
    }
    return aggrColumns;
}
function vaidateAggrFunction(aggrFn) {
    // TODO: support COUNT, then remove this assert
    assert(aggrFn.name !== 'COUNT', 'Aggregate function COUNT is not yet supported.');
    assert(VALID_AGGR_FUNCTIONS.includes(aggrFn.name), "Unknown aggregate function '" + aggrFn.name + "'.");
    assert(aggrFn.args.expr.type === 'column_ref', "Unsupported type in aggregate function '" + aggrFn.name + "'.");
}
function flattenGroupedDocs(groupedDocs) {
    var result = {};
    for (var prop in groupedDocs) {
        if (!contains(groupedDocs, prop)) {
            continue;
        }
        if (!(groupedDocs[prop] instanceof DocumentsGroup)) {
            var flatInner = flattenGroupedDocs(groupedDocs[prop]);
            for (var innerProp in flatInner) {
                if (!contains(flatInner, innerProp)) {
                    continue;
                }
                result[prop + '$$' + innerProp] = flatInner[innerProp];
            }
        }
        else {
            result[prop] = groupedDocs[prop];
        }
    }
    return result;
}
/**
 * Represents a field (prop) in a document.
 * It stores the original field name, the assigned alias, and the value.
 *
 * This is necessary in order to properly apply ORDER BY once
 * a result set has been built.
 */
var AliasedField = /** @class */ (function () {
    function AliasedField(name, alias, value) {
        this.name = name;
        this.alias = alias;
        this.value = value;
    }
    return AliasedField;
}());

var DOCUMENT_KEY_NAME = '__name__';
var FireSQL = /** @class */ (function () {
    function FireSQL(refOrOptions, options) {
        this._options = options;
        if (typeof refOrOptions === 'object') {
            if (refOrOptions instanceof firebase.firestore.DocumentReference) {
                this._ref = refOrOptions;
            }
            else if (refOrOptions instanceof firebase.firestore.Firestore) {
                this._ref = refOrOptions.doc('/');
            }
            else if (!options) {
                this._options = refOrOptions;
            }
            else {
                throw new Error('With options as the second parameter, the first parameter ' +
                    'needs to be a path string or a Firestore reference.');
            }
        }
        else {
            if (typeof refOrOptions === 'string') {
                this._path = refOrOptions;
            }
        }
        if (!this._options) {
            this._options = options || {};
        }
        if (!this._ref) {
            try {
                this._getRef();
            }
            catch (err) {
                // The default Firebase app hasn't been initialized yet.
                // No problem, we'll try again when the user launches
                // the first query.
            }
        }
    }
    Object.defineProperty(FireSQL.prototype, "ref", {
        get: function () {
            return this._getRef();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FireSQL.prototype, "firestore", {
        get: function () {
            return this._getRef().firestore;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FireSQL.prototype, "options", {
        get: function () {
            return this._options;
        },
        enumerable: true,
        configurable: true
    });
    FireSQL.prototype.query = function (sql, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var ast;
            return __generator(this, function (_a) {
                assert(typeof sql === 'string' && sql.length > 0, 'query() expects a non-empty string.');
                ast = parse(sql);
                if (ast.type === 'select') {
                    return [2 /*return*/, select_(this._getRef(), ast, __assign({}, this._options, options))];
                }
                else {
                    throw new Error("\"" + ast.type.toUpperCase() + "\" statements are not supported.");
                }
                return [2 /*return*/];
            });
        });
    };
    FireSQL.prototype._getRef = function () {
        if (!this._ref) {
            try {
                var firestore = firebase.firestore();
                this._ref = firestore.doc(this._path !== void 0 ? this._path : '/');
                delete this._path;
            }
            catch (err) {
                console.error(err);
                throw new Error('The default Firebase app has not been initialized yet.');
            }
        }
        return this._ref;
    };
    FireSQL.prototype.toJSON = function () {
        return {
            ref: this._getRef(),
            options: this._options
        };
    };
    return FireSQL;
}());
/**
 * @deprecated Class FirestoreSQL has been renamed FireSQL
 */
var FirestoreSQL = /** @class */ (function (_super) {
    __extends(FirestoreSQL, _super);
    function FirestoreSQL(ref) {
        var _this = this;
        console.warn('DEPRECATED: Class FirestoreSQL has been renamed FireSQL.\n' +
            'Using "FirestoreSQL" will stop working in future releases, update your code accordingly.');
        _this = _super.call(this, ref) || this;
        return _this;
    }
    return FirestoreSQL;
}(FireSQL));

FireSQL.prototype.rxQuery = function (sql, options) {
    assert(typeof sql === 'string' && sql.length > 0, 'rxQuery() expects a non-empty string.');
    var ast = parse(sql);
    assert(ast.type === 'select', 'Only SELECT statements are supported.');
    return rxSelect(this._getRef(), ast, __assign({}, this._options, options));
};
function rxSelect(ref, ast, options) {
    var selectOp = new SelectOperation(ref, ast, options);
    var queries = selectOp.generateQueries_();
    if (ast._next) {
        assert(ast._next.type === 'select', ' UNION statements are only supported between SELECTs.');
        // This is the UNION of 2 SELECTs, so lets process the second
        // one and merge their queries
        queries = queries.concat(selectOp.generateQueries_(ast._next));
        // FIXME: The SQL parser incorrectly attributes ORDER BY to the second
        // SELECT only, instead of to the whole UNION. Find a workaround.
    }
    var idField;
    var keepIdField;
    if (selectOp._includeId === true) {
        idField = DOCUMENT_KEY_NAME;
        keepIdField = true;
    }
    else if (typeof selectOp._includeId === 'string') {
        idField = selectOp._includeId;
        keepIdField = true;
    }
    else {
        idField = DOCUMENT_KEY_NAME;
        keepIdField = false;
    }
    var rxData = combineLatest(queries.map(function (query) { return collectionData(query, idField); }));
    return rxData.pipe(map(function (results) {
        // We have an array of results (one for each query we generated) where
        // each element is an array of documents. We need to flatten them.
        var documents = [];
        var seenDocuments = {};
        for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {
            var docs = results_1[_i];
            for (var _a = 0, docs_1 = docs; _a < docs_1.length; _a++) {
                var doc = docs_1[_a];
                // Note: for now we're only allowing to query a single collection, but
                // if at any point we change that (for example with JOINs) we'll need to
                // use the full document path here instead of just its ID
                if (!contains(seenDocuments, doc[idField])) {
                    seenDocuments[doc[idField]] = true;
                    if (!keepIdField) {
                        delete doc[idField];
                    }
                    documents.push(doc);
                }
            }
        }
        return documents;
    }), map(function (documents) {
        return selectOp.processDocuments_(queries, documents);
    }));
}

export { DOCUMENT_KEY_NAME, FireSQL, FirestoreSQL };
//# sourceMappingURL=firesql.es5.js.map
