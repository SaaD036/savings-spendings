{"map":"{\"version\":3,\"file\":\"index.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/select/index.ts\"],\"names\":[],\"mappings\":\"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\"}","code":"import * as tslib_1 from \"tslib\";\r\nimport { assert, contains, deepGet, safeGet, nameOrAlias } from '../utils';\r\nimport { applyGroupByLocally, DocumentsGroup } from './groupby';\r\nimport { applyOrderBy, applyOrderByLocally } from './orderby';\r\nimport { applyLimit, applyLimitLocally } from './limit';\r\nimport { applyWhere } from './where';\r\nimport { DOCUMENT_KEY_NAME } from '../firesql';\r\nvar VALID_AGGR_FUNCTIONS = ['MIN', 'MAX', 'SUM', 'AVG'];\r\nexport function select_(ref, ast, options) {\r\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n        var selectOp, queries, documents;\r\n        return tslib_1.__generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    selectOp = new SelectOperation(ref, ast, options);\r\n                    queries = selectOp.generateQueries_();\r\n                    return [4 /*yield*/, selectOp.executeQueries_(queries)];\r\n                case 1:\r\n                    documents = _a.sent();\r\n                    return [2 /*return*/, selectOp.processDocuments_(queries, documents)];\r\n            }\r\n        });\r\n    });\r\n}\r\nvar SelectOperation = /** @class */ (function () {\r\n    function SelectOperation(_ref, _ast, options) {\r\n        this._ref = _ref;\r\n        this._ast = _ast;\r\n        // We need to determine if we have to include\r\n        // the document's ID (__name__) in the results.\r\n        this._includeId = options.includeId || false;\r\n        if (!this._includeId && Array.isArray(_ast.columns)) {\r\n            for (var i = 0; i < _ast.columns.length; i++) {\r\n                if (_ast.columns[i].expr.type === 'column_ref') {\r\n                    if (_ast.columns[i].expr.column === DOCUMENT_KEY_NAME) {\r\n                        this._includeId = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this._includeId === void 0) {\r\n            this._includeId = false;\r\n        }\r\n    }\r\n    SelectOperation.prototype.generateQueries_ = function (ast) {\r\n        ast = ast || this._ast;\r\n        assert(ast.from.length === 1, 'Only one collection at a time (no JOINs yet).');\r\n        var colName = ast.from[0].table;\r\n        var collection = this._ref.collection(colName);\r\n        var queries = [collection];\r\n        /*\r\n       * We'd need this if we end up implementing JOINs, but for now\r\n       * it's unnecessary since we're only querying a single collection\r\n       \n        // Keep track of aliased \"tables\" (collections)\r\n        const aliasedCollections: { [k: string]: string } = {};\r\n        if (ast.from[0].as.length > 0) {\r\n          aliasedCollections[ast.from[0].as] = colName;\r\n        } else {\r\n          aliasedCollections[colName] = colName;\r\n        }\r\n       */\r\n        if (ast.where) {\r\n            queries = applyWhere(queries, ast.where);\r\n        }\r\n        if (ast.orderby) {\r\n            queries = applyOrderBy(queries, ast.orderby);\r\n            /*\r\n             FIXME: the following query throws an error:\r\n                SELECT city, name\r\n                FROM restaurants\r\n                WHERE city IN ('Nashvile', 'Denver')\r\n                ORDER BY city, name\r\n        \n             It happens because \"WHERE ... IN ...\" splits into 2 separate\r\n             queries with a \"==\" filter, and an order by clause cannot\r\n             contain a field with an equality filter:\r\n                ...where(\"city\",\"==\",\"Denver\").orderBy(\"city\")\r\n            */\r\n        }\r\n        // if (ast.groupby) {\r\n        //   throw new Error('GROUP BY not supported yet');\r\n        // }\r\n        if (ast.limit) {\r\n            // First we apply the limit to each query we may have\r\n            // and later we'll apply it again locally to the\r\n            // merged set of documents, in case we end up with too many.\r\n            queries = applyLimit(queries, ast.limit);\r\n        }\r\n        if (ast._next) {\r\n            assert(ast._next.type === 'select', ' UNION statements are only supported between SELECTs.');\r\n            // This is the UNION of 2 SELECTs, so lets process the second\r\n            // one and merge their queries\r\n            queries = queries.concat(this.generateQueries_(ast._next));\r\n            // FIXME: The SQL parser incorrectly attributes ORDER BY to the second\r\n            // SELECT only, instead of to the whole UNION. Find a workaround.\r\n        }\r\n        return queries;\r\n    };\r\n    SelectOperation.prototype.executeQueries_ = function (queries) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var documents, seenDocuments, err_1;\r\n            var _this = this;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        documents = [];\r\n                        seenDocuments = {};\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, Promise.all(queries.map(function (query) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\r\n                                var snapshot, numDocs, i, docSnap, docPath, docData;\r\n                                return tslib_1.__generator(this, function (_a) {\r\n                                    switch (_a.label) {\r\n                                        case 0: return [4 /*yield*/, query.get()];\r\n                                        case 1:\r\n                                            snapshot = _a.sent();\r\n                                            numDocs = snapshot.docs.length;\r\n                                            for (i = 0; i < numDocs; i++) {\r\n                                                docSnap = snapshot.docs[i];\r\n                                                docPath = docSnap.ref.path;\r\n                                                if (!contains(seenDocuments, docPath)) {\r\n                                                    docData = docSnap.data();\r\n                                                    if (this._includeId) {\r\n                                                        docData[typeof this._includeId === 'string'\r\n                                                            ? this._includeId\r\n                                                            : DOCUMENT_KEY_NAME] = docSnap.id;\r\n                                                    }\r\n                                                    documents.push(docData);\r\n                                                    seenDocuments[docPath] = true;\r\n                                                }\r\n                                            }\r\n                                            return [2 /*return*/];\r\n                                    }\r\n                                });\r\n                            }); }))];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        err_1 = _a.sent();\r\n                        // TODO: handle error?\r\n                        throw err_1;\r\n                    case 4: return [2 /*return*/, documents];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    SelectOperation.prototype.processDocuments_ = function (queries, documents) {\r\n        if (documents.length === 0) {\r\n            return [];\r\n        }\r\n        else {\r\n            if (this._ast.groupby) {\r\n                var groupedDocs = applyGroupByLocally(documents, this._ast.groupby);\r\n                return this._processGroupedDocs(queries, groupedDocs);\r\n            }\r\n            else {\r\n                return this._processUngroupedDocs(queries, documents);\r\n            }\r\n        }\r\n    };\r\n    SelectOperation.prototype._processUngroupedDocs = function (queries, documents) {\r\n        var _this = this;\r\n        if (this._ast.orderby && queries.length > 1) {\r\n            // We merged more than one query into a single set of documents\r\n            // so we need to order the documents again, this time client-side.\r\n            documents = applyOrderByLocally(documents, this._ast.orderby);\r\n        }\r\n        if (this._ast.limit && queries.length > 1) {\r\n            // We merged more than one query into a single set of documents\r\n            // so we need to apply the limit again, this time client-side.\r\n            documents = applyLimitLocally(documents, this._ast.limit);\r\n        }\r\n        if (typeof this._ast.columns === 'string' && this._ast.columns === '*') {\r\n            // Return all fields from the documents\r\n        }\r\n        else if (Array.isArray(this._ast.columns)) {\r\n            var aggrColumns = getAggrColumns(this._ast.columns);\r\n            if (aggrColumns.length > 0) {\r\n                var docsGroup = new DocumentsGroup();\r\n                docsGroup.documents = documents;\r\n                aggregateDocuments(docsGroup, aggrColumns);\r\n                /// Since there is no GROUP BY and we already computed all\r\n                // necessary aggregated values, at this point we only care\r\n                // about the first document in the list. Anything else is\r\n                // irrelevant.\r\n                var resultEntry = this._buildResultEntry(docsGroup.documents[0], docsGroup.aggr);\r\n                documents = [resultEntry];\r\n            }\r\n            else {\r\n                documents = documents.map(function (doc) { return _this._buildResultEntry(doc); });\r\n            }\r\n        }\r\n        else {\r\n            // We should never reach here\r\n            throw new Error('Internal error (ast.columns).');\r\n        }\r\n        return documents;\r\n    };\r\n    SelectOperation.prototype._processGroupedDocs = function (queries, groupedDocs) {\r\n        var _this = this;\r\n        assert(this._ast.columns !== '*', 'Cannot \"SELECT *\" when using GROUP BY.');\r\n        var aggrColumns = getAggrColumns(this._ast.columns);\r\n        var groups = flattenGroupedDocs(groupedDocs);\r\n        if (aggrColumns.length === 0) {\r\n            // We're applying a GROUP BY but none of the fields requested\r\n            // in the SELECT are an aggregate function. In this case we\r\n            // just return an entry for the first document.\r\n            var firstGroupKey = Object.keys(groups)[0];\r\n            var firstGroup = groups[firstGroupKey];\r\n            var firstDoc = firstGroup.documents[0];\r\n            return [this._buildResultEntry(firstDoc)];\r\n        }\r\n        else {\r\n            var results_1 = [];\r\n            // TODO: ORDER BY\r\n            assert(!this._ast.orderby, 'ORDER BY is not yet supported when using GROUP BY.');\r\n            // TODO: LIMIT\r\n            assert(!this._ast.limit, 'LIMIT is not yet supported when using GROUP BY.');\r\n            Object.keys(groups).forEach(function (groupKey) {\r\n                var docsGroup = groups[groupKey];\r\n                aggregateDocuments(docsGroup, aggrColumns);\r\n                var resultEntry = _this._buildResultEntry(docsGroup.documents[0], docsGroup.aggr);\r\n                results_1.push(resultEntry);\r\n            });\r\n            return results_1;\r\n        }\r\n    };\r\n    SelectOperation.prototype._buildResultEntry = function (document, aggregate, asFieldArray) {\r\n        if (asFieldArray === void 0) { asFieldArray = false; }\r\n        var idIncluded = false;\r\n        var columns = this._ast.columns;\r\n        var resultFields = columns.reduce(function (entries, column) {\r\n            var fieldName;\r\n            var fieldAlias;\r\n            switch (column.expr.type) {\r\n                case 'column_ref':\r\n                    fieldName = column.expr.column;\r\n                    fieldAlias = nameOrAlias(fieldName, column.as);\r\n                    entries.push(new AliasedField(fieldName, fieldAlias, deepGet(document, fieldName)));\r\n                    if (fieldName === DOCUMENT_KEY_NAME) {\r\n                        idIncluded = true;\r\n                    }\r\n                    break;\r\n                case 'aggr_func':\r\n                    vaidateAggrFunction(column.expr);\r\n                    fieldName = column.expr.args.expr.column;\r\n                    fieldAlias = nameOrAlias(fieldName, column.as, column.expr);\r\n                    entries.push(new AliasedField(fieldName, fieldAlias, aggregate[column.expr.name.toLowerCase()][fieldName]));\r\n                    break;\r\n                default:\r\n                    throw new Error('Unsupported type in SELECT.');\r\n            }\r\n            return entries;\r\n        }, []);\r\n        if (this._includeId && !idIncluded) {\r\n            resultFields.push(new AliasedField(DOCUMENT_KEY_NAME, typeof this._includeId === 'string'\r\n                ? this._includeId\r\n                : DOCUMENT_KEY_NAME, safeGet(document, DOCUMENT_KEY_NAME)));\r\n        }\r\n        if (asFieldArray) {\r\n            return resultFields;\r\n        }\r\n        else {\r\n            return resultFields.reduce(function (doc, field) {\r\n                doc[field.alias] = field.value;\r\n                return doc;\r\n            }, {});\r\n        }\r\n    };\r\n    return SelectOperation;\r\n}());\r\nexport { SelectOperation };\r\n/*************************************************/\r\nfunction aggregateDocuments(docsGroup, functions) {\r\n    var numDocs = docsGroup.documents.length;\r\n    var _loop_1 = function (i) {\r\n        var doc = docsGroup.documents[i];\r\n        // If the same field is used in more than one aggregate function\r\n        // we don't want to sum its value more than once.\r\n        var skipSum = {};\r\n        functions.forEach(function (fn) {\r\n            var column = fn.args.expr.column;\r\n            var value = safeGet(doc, column);\r\n            var isNumber = !Number.isNaN(value);\r\n            switch (fn.name) {\r\n                case 'AVG':\r\n                    // Lets put a value so that later we know we have to compute this avg\r\n                    docsGroup.aggr.avg[column] = 0;\r\n                // tslint:disable-next-line:no-switch-case-fall-through\r\n                case 'SUM':\r\n                    if (safeGet(skipSum, column) !== true) {\r\n                        skipSum[column] = true;\r\n                        if (!contains(docsGroup.aggr.total, column)) {\r\n                            docsGroup.aggr.total[column] = 0;\r\n                            docsGroup.aggr.sum[column] = 0;\r\n                        }\r\n                        value = Number(value);\r\n                        assert(!Number.isNaN(value), \"Can't compute aggregate function \" + fn.name + \"(\" + column + \") because some values are not numbers.\");\r\n                        docsGroup.aggr.total[column] += 1;\r\n                        docsGroup.aggr.sum[column] += value;\r\n                        // FIXME: if the numbers are big we could easily go out of bounds in this sum\r\n                    }\r\n                    break;\r\n                case 'MIN':\r\n                    assert(isNumber || typeof value === 'string', \"Aggregate function MIN(\" + column + \") can only be performed on numbers or strings\");\r\n                    if (!contains(docsGroup.aggr.min, column)) {\r\n                        docsGroup.aggr.min[column] = value;\r\n                    }\r\n                    else {\r\n                        if (!Number.isNaN(docsGroup.aggr.min[column])) {\r\n                            // The current minimum is a number\r\n                            assert(isNumber, \"Can't compute aggregate function MIN(\" + column + \") because some values are not numbers.\");\r\n                            value = Number(value);\r\n                        }\r\n                        if (value < docsGroup.aggr.min[column]) {\r\n                            docsGroup.aggr.min[column] = value;\r\n                        }\r\n                    }\r\n                    break;\r\n                case 'MAX':\r\n                    assert(isNumber || typeof value === 'string', \"Aggregate function MAX(\" + column + \") can only be performed on numbers or strings\");\r\n                    if (!contains(docsGroup.aggr.max, column)) {\r\n                        docsGroup.aggr.max[column] = value;\r\n                    }\r\n                    else {\r\n                        if (!Number.isNaN(docsGroup.aggr.max[column])) {\r\n                            // The current maximum is a number\r\n                            assert(isNumber, \"Can't compute aggregate function MAX(\" + column + \") because some values are not numbers.\");\r\n                            value = Number(value);\r\n                        }\r\n                        if (value > docsGroup.aggr.max[column]) {\r\n                            docsGroup.aggr.max[column] = value;\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        });\r\n    };\r\n    for (var i = 0; i < numDocs; i++) {\r\n        _loop_1(i);\r\n    }\r\n    // Compute any necessary averages\r\n    Object.keys(docsGroup.aggr.avg).forEach(function (group) {\r\n        docsGroup.aggr.avg[group] =\r\n            docsGroup.aggr.sum[group] / docsGroup.aggr.total[group];\r\n    });\r\n    return docsGroup;\r\n}\r\nfunction getAggrColumns(columns) {\r\n    var aggrColumns = [];\r\n    if (columns !== '*') {\r\n        columns.forEach(function (astColumn) {\r\n            if (astColumn.expr.type === 'aggr_func') {\r\n                vaidateAggrFunction(astColumn.expr);\r\n                aggrColumns.push(astColumn.expr);\r\n            }\r\n            else {\r\n                assert(astColumn.expr.type === 'column_ref', 'Only field names and aggregate functions are supported in SELECT statements.');\r\n            }\r\n        });\r\n    }\r\n    return aggrColumns;\r\n}\r\nfunction vaidateAggrFunction(aggrFn) {\r\n    // TODO: support COUNT, then remove this assert\r\n    assert(aggrFn.name !== 'COUNT', 'Aggregate function COUNT is not yet supported.');\r\n    assert(VALID_AGGR_FUNCTIONS.includes(aggrFn.name), \"Unknown aggregate function '\" + aggrFn.name + \"'.\");\r\n    assert(aggrFn.args.expr.type === 'column_ref', \"Unsupported type in aggregate function '\" + aggrFn.name + \"'.\");\r\n}\r\nfunction flattenGroupedDocs(groupedDocs) {\r\n    var result = {};\r\n    for (var prop in groupedDocs) {\r\n        if (!contains(groupedDocs, prop)) {\r\n            continue;\r\n        }\r\n        if (!(groupedDocs[prop] instanceof DocumentsGroup)) {\r\n            var flatInner = flattenGroupedDocs(groupedDocs[prop]);\r\n            for (var innerProp in flatInner) {\r\n                if (!contains(flatInner, innerProp)) {\r\n                    continue;\r\n                }\r\n                result[prop + '$$' + innerProp] = flatInner[innerProp];\r\n            }\r\n        }\r\n        else {\r\n            result[prop] = groupedDocs[prop];\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Represents a field (prop) in a document.\r\n * It stores the original field name, the assigned alias, and the value.\r\n *\r\n * This is necessary in order to properly apply ORDER BY once\r\n * a result set has been built.\r\n */\r\nvar AliasedField = /** @class */ (function () {\r\n    function AliasedField(name, alias, value) {\r\n        this.name = name;\r\n        this.alias = alias;\r\n        this.value = value;\r\n    }\r\n    return AliasedField;\r\n}());\r\n//# sourceMappingURL=index.js.map","dts":{"name":"/mnt/c/www/npm-packages/fire-sql/dist/types/select/index.d.ts","writeByteOrderMark":false,"text":"import { SQL_Select } from 'node-sqlparser';\r\nimport { DocumentData } from '../utils';\r\nimport { QueryOptions } from '../firesql';\r\nexport declare function select_(ref: firebase.firestore.DocumentReference, ast: SQL_Select, options: QueryOptions): Promise<DocumentData[]>;\r\nexport declare class SelectOperation {\r\n    private _ref;\r\n    private _ast;\r\n    _includeId?: boolean | string;\r\n    constructor(_ref: firebase.firestore.DocumentReference, _ast: SQL_Select, options: QueryOptions);\r\n    generateQueries_(ast?: SQL_Select): firebase.firestore.Query[];\r\n    executeQueries_(queries: firebase.firestore.Query[]): Promise<DocumentData[]>;\r\n    processDocuments_(queries: firebase.firestore.Query[], documents: DocumentData[]): DocumentData[];\r\n    private _processUngroupedDocs;\r\n    private _processGroupedDocs;\r\n    private _buildResultEntry;\r\n}\r\n"}}
